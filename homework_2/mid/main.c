å¥½ç¬‘å—
u8b19
éš±å½¢

å“ˆå¯†è›¤ â€” 2023/10/20 01:13
åœ–ç‰‡
å“ˆå¯†è›¤ â€” 2023/10/20 09:17
å¦‚æœæˆ‘æƒ³é–‹å§‹åˆ·leetcodeçš„é¡Œç›®
ä½ è¦ºå¾—æˆ‘è¦ç”¨å“ªå€‹ç¨‹å¼èªæ³•å»å¯«
C++,C,python,JAVA
å¥½ç¬‘å— â€” 2023/10/23 12:26
ä½ æœ‰åœ¨å¯«é›»å­å­¸çš„é¡Œç›®å—?
å¥½ç¬‘å— â€” 2023/10/30 21:10
å¤§å“¥æ±‚æ•‘çµ„åˆèªè¨€ä½œæ¥­
        AREA    prog1, CODE, READWRITE
        ENTRY

data1    DCW 0x8ECC, 0xFE37, -149
data2    DCD 0xFE37, 1, 5, 20
data3    DCB 0XCF, 23, 39, 0x54, 250
data4    DCWU 0x1234
data5    DCB 255
data6    DCDU 0x12345678, -4321
data7    DCB 0xA3
        ALIGN 4,3
data8    DCWU 0xFC25
        ALIGN
data9     DCB "MVP_N.Jokic", 0
data10     DCW 0xEF12

stop    B    stop
        END
é€™æ¨£å¯«æ˜¯å°çš„å—?
å“ˆå¯†è›¤ â€” 2023/10/30 22:21
å°
ç„¶å¾Œè¦å»æ‰¾ä½ç½®
å¥½ç¬‘å— â€” 2023/10/30 22:22
ä¸æ‡‚
å“ˆå¯†è›¤ â€” 2023/10/30 22:27
ä»–ä¸æ˜¯æ¯æ¬¡éƒ½è¦ä½ å»ç¯€åˆ°è¨˜æ†¶é«”é‚£è£
å°±æ˜¯è¦å»å¾é‚£è£æ‰¾
å¥½ç¬‘å— â€” 2023/10/30 23:17
äº†è§£
å¥½ç¬‘å— â€” 2023/11/01 14:59
å•å€‹å•é¡Œ
å“ˆå¯†è›¤ â€” 2023/11/01 15:00
?
å¥½ç¬‘å— â€” 2023/11/01 15:00
BIC æ­¸é›¶çš„ä½æ•¸æ˜¯ç”¨äºŒé€²ä½ç®—å—ï¼Ÿ
é‚„æœ‰ ORR çš„ set æ˜¯ä»€éº¼æ„æ€ï¼Ÿ 
å“ˆå¯†è›¤ â€” 2023/11/01 15:05
é‚£æ˜¯ç¬¬å¹¾é¡Œ
å¥½ç¬‘å— â€” 2023/11/01 15:06
åœ–ç‰‡
ä½ éŒ¯éäº†ä¾†è‡ª 
å“ˆå¯†è›¤
 é•·é”å¹¾ç§’çš„é€šè©±ã€‚
 â€” 2023/11/07 21:56
å¥½ç¬‘å— â€” 2023/11/07 21:57
æ€éº¼äº†ï¼Ÿ
å“ˆå¯†è›¤ â€” 2023/11/07 21:58
å•ä½ å€‹å•é¡Œ
å¥½ç¬‘å— â€” 2023/11/07 21:58
å˜¿
å“ˆå¯†è›¤ â€” 2023/11/07 21:58
æˆ‘ç¾åœ¨åœ¨è·Ÿåˆ¥äººçµ„éšŠåƒåŠ æ•¸ä½è½‰å‹&æ·¨é›¶è½‰å‹ç«¶è³½
é‚„å·®ä¸€å€‹äºº
è¦ä¸‰å€‹äºº
ä½ æœ‰èˆˆè¶£å—ğŸ¥º
å¥½ç¬‘å— â€” 2023/11/07 21:59
å•¥æ´»å‹•å•Š?
å“ˆå¯†è›¤ â€” 2023/11/07 22:00
ç¾åœ¨åªæœ‰6å€‹éšŠä¼å ±å
https://enroll.tku.edu.tw/course.aspx?cid=FKLX20231212
æ±ºè³½æœƒå–10éšŠ
12è™Ÿæˆªæ­¢å ±å
ä»–è¦3å€‹äºº
æˆ‘å€‘åªæœ‰å…©å€‹äºº
ä¸æ˜¯ç‰¹åˆ¥é›£çš„æ¯”è³½
å“ˆå¯†è›¤ â€” æ˜¨å¤© 14:37
è³‡æ–™çµæ§‹è€ƒå¤é¡Œç¿»è­¯
ç¬¬ä¸€éƒ¨åˆ†ï¼š

   (1) ä½¿ç”¨ rand()%100+1 ç”Ÿæˆ6å€‹éš¨æ©Ÿæ•¸å­—ï¼Œå°‡é€™äº›æ•¸å­—ä¾æ¬¡è¼¸å‡ºï¼ˆæ¯å€‹æ•¸å­—ä¹‹é–“ç”¨ä¸€å€‹ç©ºæ ¼åˆ†éš”ï¼Œåœ¨åŒä¸€è¡Œé¡¯ç¤ºï¼‰ï¼Œä¸¦å°‡é€™äº›æ•¸å­—ä¾æ¬¡å£“å…¥ä¸€å€‹å‰µå»ºçš„å †ç–Šï¼ˆçµæ§‹é«”å †ç–ŠSï¼‰ä¸­ã€‚
   (2) ç‚ºæ•´æ•¸xè³¦å€¼ç‚ºå †ç–ŠSä¸­å¾é ‚éƒ¨æ•¸éä¾†çš„ç¬¬11å€‹å…ƒç´ ï¼Œç„¶å¾Œè¼¸å‡ºxçš„å€¼ã€‚
   (3) å†æ¬¡ä½¿ç”¨ rand()%100+1 ç”Ÿæˆ21å€‹éš¨æ©Ÿæ•¸å­—ï¼Œå°‡é€™äº›æ•¸å­—ä¾æ¬¡è¼¸å‡ºï¼ˆæ¯å€‹æ•¸å­—ä¹‹é–“ç”¨ä¸€å€‹ç©ºæ ¼åˆ†éš”ï¼Œæ¯è¡Œé¡¯ç¤º7å€‹æ•¸å­—ï¼‰ï¼Œä¸¦å°‡é€™äº›æ•¸å­—ä¾æ¬¡å£“å…¥å †ç–ŠSä¸­ã€‚
   (4) ç‚ºæ•´æ•¸yè³¦å€¼ç‚ºå †ç–ŠSä¸­å¾é ‚éƒ¨æ•¸éä¾†çš„ç¬¬11å€‹å…ƒç´ ï¼Œç„¶å¾Œè¼¸å‡ºyçš„å€¼ï¼Œä½†ä¸æ”¹è®ŠSçš„å…§å®¹ã€‚
   (5) ç‚ºæ•´æ•¸zè³¦å€¼ç‚ºå †ç–ŠSä¸­å¾åº•éƒ¨æ•¸éä¾†çš„ç¬¬2å€‹å…ƒç´ ï¼Œç„¶å¾Œè¼¸å‡ºzçš„å€¼ï¼Œä½†ä¸æ”¹è®ŠSçš„å…§å®¹ã€‚
   (6) ç‚ºæ•´æ•¸wè³¦å€¼ç‚ºå †ç–ŠSä¸­å¾åº•éƒ¨æ•¸éä¾†çš„ç¬¬3å€‹å…ƒç´ ï¼Œç„¶å¾Œè¼¸å‡ºwçš„å€¼ï¼Œä½†ä¸æ”¹è®ŠSçš„å…§å®¹ã€‚
   (7) è¼¸å‡ºå †ç–ŠSä¸­å¾é ‚éƒ¨åˆ°åº•éƒ¨çš„æ‰€æœ‰æ•¸å­—ï¼ˆæ¯å€‹æ•¸å­—ä¹‹é–“ç”¨ä¸€å€‹ç©ºæ ¼åˆ†éš”ï¼Œæ¯è¡Œé¡¯ç¤º7å€‹æ•¸å­—ï¼‰ã€‚

ç¬¬äºŒéƒ¨åˆ†ï¼š

   (1) (a) ä½¿ç”¨ rand()%100+1 ç”Ÿæˆ21å€‹éš¨æ©Ÿæ•¸å­—ï¼Œå°‡é€™äº›æ•¸å­—ä¾æ¬¡è¼¸å‡ºï¼ˆæ¯å€‹æ•¸å­—ä¹‹é–“ç”¨ä¸€å€‹ç©ºæ ¼åˆ†éš”ï¼Œæ¯è¡Œé¡¯ç¤º7å€‹æ•¸å­—ï¼‰ï¼Œä¸¦å°‡é€™äº›æ•¸å­—ä¾æ¬¡åŠ å…¥ä¸€å€‹å‰µå»ºçš„éšŠåˆ—ä¸­ã€‚
   (b) å°‡æ•´æ•¸wè³¦å€¼ç‚ºéšŠåˆ—å°¾éƒ¨çš„ç¬¬2å€‹å…ƒç´ ï¼Œç„¶å¾Œè¼¸å‡ºwçš„å€¼ã€‚
   (2) (a) ä½¿ç”¨ rand()%100+1 ç”Ÿæˆ21å€‹éš¨æ©Ÿæ•¸å­—ï¼Œå°‡é€™äº›æ•¸å­—ä¾æ¬¡è¼¸å‡ºï¼ˆæ¯å€‹æ•¸å­—ä¹‹é–“ç”¨ä¸€å€‹ç©ºæ ¼åˆ†éš”ï¼Œæ¯è¡Œé¡¯ç¤º7å€‹æ•¸å­—ï¼‰ï¼Œç„¶å¾Œå°‡é€™äº›æ•¸å­—ä¾æ¬¡æ·»åŠ åˆ°ä¸€å€‹å‰µå»ºçš„éšŠåˆ—ä¸­ã€‚
   (b) å°‡æ•´æ•¸wè³¦å€¼ç‚ºéšŠåˆ—å°¾éƒ¨çš„ç¬¬3å€‹å…ƒç´ ï¼Œç„¶å¾Œè¼¸å‡ºwçš„å€¼ã€‚
   (3) (a) ä½¿ç”¨ rand()%100+1 ç”Ÿæˆ21å€‹éš¨æ©Ÿæ•¸å­—ï¼Œå°‡é€™äº›æ•¸å­—ä¾æ¬¡è¼¸å‡ºï¼ˆæ¯å€‹æ•¸å­—ä¹‹é–“ç”¨ä¸€å€‹ç©ºæ ¼åˆ†éš”ï¼Œæ¯è¡Œé¡¯ç¤º7å€‹æ•¸å­—ï¼‰ï¼Œç„¶å¾Œå°‡é€™äº›æ•¸å­—ä¾æ¬¡æ·»åŠ åˆ°ä¸€å€‹å‰µå»ºçš„éšŠåˆ—ï¼ˆçµæ§‹é«”éšŠåˆ—Qï¼‰ä¸­ã€‚
   (b) å°‡æ•´æ•¸mè³¦å€¼ç‚ºéšŠåˆ—é ­éƒ¨çš„ç¬¬11å€‹å…ƒç´ ï¼Œç„¶å¾Œè¼¸å‡ºmçš„å€¼ï¼Œä½†ä¸æ”¹è®ŠQçš„å…§å®¹ã€‚
   (c) è¼¸å‡ºå¾éšŠåˆ—é ­éƒ¨åˆ°å°¾éƒ¨çš„æ‰€æœ‰æ•¸å­—ï¼ˆæ¯å€‹æ•¸å­—ä¹‹é–“ç”¨ä¸€å€‹ç©ºæ ¼åˆ†éš”ï¼Œæ¯è¡Œé¡¯ç¤º7å€‹æ•¸å­—ï¼‰ã€‚

ä¿®æ”¹æ‹¬è™ŸåŒ¹é…ç¨‹å¼ï¼š

   (1) ä¿®æ”¹ç¨‹å¼ä»¥åŒ…æ‹¬ä¸‰ç¨®é¡å‹çš„æ‹¬è™Ÿï¼š()ã€[]å’Œ{}ã€‚è¼¸å…¥è¡¨é”å¼{(a+b)c]}}/{[d[e+f]ã€‚è¼¸å‡ºæ‡‰ç‚ºï¼š
   
   (1,5)
   åœ¨ç¬¬8å€‹ä½ç½®çš„å³æ‹¬è™Ÿ]æ²’æœ‰åŒ¹é…çš„å·¦æ‹¬è™Ÿ[
   {0,9}
   åœ¨ç¬¬10å€‹ä½ç½®çš„å³æ‹¬è™Ÿ}æ²’æœ‰åŒ¹é…çš„å·¦æ‹¬è™Ÿ{
   [16,20] 
   åœ¨ç¬¬13å€‹ä½ç½®çš„å·¦æ‹¬è™Ÿ[æ²’æœ‰åŒ¹é…çš„å³æ‹¬è™Ÿ]
   åœ¨ç¬¬12å€‹ä½ç½®çš„å·¦æ‹¬è™Ÿ{æ²’æœ‰åŒ¹é…çš„å³æ‹¬è™Ÿ}
   

   (2) ä¿®æ”¹ç¨‹å¼ä»¥åƒ…åŒ…æ‹¬å…©ç¨®é¡å‹çš„æ‹¬è™Ÿï¼š()å’Œ[]ã€‚è¼¸å…¥è¡¨é”å¼(((a+b)]*[[[c+d)ã€‚è¼¸å‡ºæ‡‰ç‚ºï¼š
   
   (2,6)
   åœ¨ç¬¬7å€‹ä½ç½®çš„å³æ‹¬è™Ÿ]æ²’æœ‰åŒ¹é…çš„å·¦æ‹¬è™Ÿ[
   åœ¨ç¬¬15å€‹ä½ç½®çš„å³æ‹¬è™Ÿ)æ²’æœ‰åŒ¹é…çš„å·¦æ‹¬è™Ÿ(
   [10,16] 
   åœ¨ç¬¬9å€‹ä½ç½®çš„å·¦æ‹¬è™Ÿ[æ²’æœ‰åŒ¹é…çš„å³æ‹¬è™Ÿ]
   åœ¨ç¬¬0å€‹ä½ç½®çš„å·¦æ‹¬è™Ÿ(æ²’æœ‰åŒ¹é…çš„å³æ‹¬è™Ÿ)
   
é™„ä»¶æª”æ¡ˆé¡å‹ï¼šdocument
411440422__.docx
19.22 KB
å¥½ç¬‘å— â€” æ˜¨å¤© 15:23
https://orly.nanmu.me/
O'RLY Cover Generator
Generate your O'RLY Cover here to entertain yourself and friends.
åœ–ç‰‡
å“ˆå¯†è›¤ â€” æ˜¨å¤© 15:51
é™„ä»¶æª”æ¡ˆé¡å‹ï¼šdocument
1c70fefac7cc5dfd.docx
21.62 KB
ç¬¬äºŒéƒ¨åˆ†ï¼š
(1) æ’°å¯«ä¸€å€‹ç¨‹å¼ï¼ŒæŒ‰ä»¥ä¸‹æ­¥é©ŸåŸ·è¡Œï¼ˆä½¿ç”¨ lastOperationIsdeleteqï¼‰ï¼š
(a) ä½¿ç”¨ rand()%100+1 ä¾†å–å¾— 21 å€‹éš¨æ©Ÿæ•¸ï¼ŒæŒ‰ä»¥ä¸‹æ–¹å¼è¼¸å‡ºé€™äº›æ•¸å­—ï¼ˆä¸€å€‹æ¥ä¸€å€‹ï¼Œä¸­é–“ä»¥ç©ºæ ¼åˆ†éš”ï¼Œæ¯è¡Œé¡¯ç¤º 7 å€‹æ•¸å­—ï¼‰ï¼Œç„¶å¾Œä¾æ¬¡å°‡é€™äº›æ•¸å­—å£“å…¥ä¸€å€‹å·²å‰µå»ºçš„ä½‡åˆ—ã€‚
(b) æŒ‡å®šæ•´æ•¸ w ç‚ºä½‡åˆ—å°¾ç«¯å¾€å‰æ•¸ç¬¬ 2 å€‹å…ƒç´ ï¼Œç„¶å¾Œè¼¸å‡º w çš„å€¼ã€‚
(2) æ’°å¯«ä¸€å€‹ç¨‹å¼ï¼ŒæŒ‰ä»¥ä¸‹æ­¥é©ŸåŸ·è¡Œï¼ˆä½¿ç”¨ TotalInQueueï¼‰ï¼š
(a) ä½¿ç”¨ rand()%100+1 ä¾†å–å¾— 21 å€‹éš¨æ©Ÿæ•¸ï¼ŒæŒ‰ä»¥ä¸‹æ–¹å¼è¼¸å‡ºé€™äº›æ•¸å­—ï¼ˆä¸€å€‹æ¥ä¸€å€‹ï¼Œä¸­é–“ä»¥ç©ºæ ¼åˆ†éš”ï¼Œæ¯è¡Œé¡¯ç¤º 7 å€‹æ•¸å­—ï¼‰ï¼Œç„¶å¾Œé€å€‹å°‡é€™äº›æ•¸å­—æ·»åŠ åˆ°ä¸€å€‹å·²å‰µå»ºçš„ä½‡åˆ—ä¸­ã€‚
(b) æŒ‡å®šæ•´æ•¸ w ç‚ºä½‡åˆ—å°¾ç«¯å¾€å‰æ•¸ç¬¬ 3 å€‹å…ƒç´ ï¼Œç„¶å¾Œè¼¸å‡º w çš„å€¼ã€‚
(3) æ’°å¯«ä¸€å€‹ç¨‹å¼ï¼ŒæŒ‰ä»¥ä¸‹æ­¥é©ŸåŸ·è¡Œï¼ˆä½¿ç”¨ sacrificing an element spaceï¼‰ï¼š
(a) ä½¿ç”¨ rand()%100+1 ä¾†å–å¾— 21 å€‹éš¨æ©Ÿæ•¸ï¼ŒæŒ‰ä»¥ä¸‹æ–¹å¼è¼¸å‡ºé€™äº›æ•¸å­—ï¼ˆä¸€å€‹æ¥ä¸€å€‹ï¼Œä¸­é–“ä»¥ç©ºæ ¼åˆ†éš”ï¼Œæ¯è¡Œé¡¯ç¤º 7 å€‹æ•¸å­—ï¼‰ï¼Œç„¶å¾Œé€å€‹å°‡é€™äº›æ•¸å­—æ·»åŠ åˆ°ä¸€å€‹å·²å‰µå»ºçš„ä½‡åˆ—ï¼ˆçµæ§‹é«”ä½‡åˆ— Qï¼‰ä¸­ã€‚
(b) æŒ‡å®šæ•´æ•¸ m ç‚º Q çš„é ­éƒ¨å¾€ä¸‹æ•¸ç¬¬ 11 å€‹å…ƒç´ ï¼Œç„¶å¾Œè¼¸å‡º m çš„å€¼ï¼ŒåŒæ™‚ä¸æ”¹è®Š Q çš„ç‹€æ…‹ã€‚
(c) æŒ‰ä»¥ä¸‹æ–¹å¼è¼¸å‡º Q ä¸­çš„æ•¸å­—ï¼ˆä¸€å€‹æ¥ä¸€å€‹ï¼Œä¸­é–“ä»¥ç©ºæ ¼åˆ†éš”ï¼Œæ¯è¡Œé¡¯ç¤º 7 å€‹æ•¸å­—ï¼‰ï¼Œä¾æ¬¡å¾ Q çš„é ­éƒ¨åˆ°å°¾ç«¯è¼¸å‡ºé€™äº›æ•¸å­—
å“ˆå¯†è›¤ â€” æ˜¨å¤© 17:45
#include <stdio.h>
#include <stdlib.h>
#define SIZE 100
//411440422 Travis Chan
int top = -1;

struct element {
    char type;
    int pos;
};

struct element stack[SIZE];

int full() {
    return top == 99;
}

int empty() {
    return top == -1;
}

void push(struct element *p) {
    if(full()) {
        printf("the stack is full\n");
        exit(1);
    }
    stack[++top].type = p->type;
    stack[top].pos = p->pos;
}

struct element *pop() {
    if(empty()) {
        printf("the stack is empty\n");
        exit(1);
    }
    return &stack[top--];
}

char other_side(char x) {
    if(x == '(') return ')';
    if(x == ')') return '(';
    if(x == '[') return ']';
    if(x == ']') return '[';
    if(x == '{') return '}';
    if(x == '}') return '{';
}

//411440422 Travis Chan 

int main(void) {
    char symb;
    int pos = 0;
    struct element data;
    struct element *p;    
    while((symb = getchar())!="\n") {
        if(symb == '(' || symb == '[' || symb == '{') {
            data.type = symb;
            data.pos = pos;
            push(&data);
        }
    }
    return 0;
}
å¥½ç¬‘å— â€” æ˜¨å¤© 17:58
int main(int argc, char *argv[]) {

    struct parenthesis stack[SIZE] = {};
    int top = -1;
    int position = 0;

    while (1) {
        char symb = getchar();

        if (symb == '\n' || symb == EOF) {
            break;
        }
        
        if (symb == '(' || symb == '[' || symb == '{'){
            push(stack, &top, position, symb);

        } else if (symb == ')' || symb == ']' || symb == '}') {// symb = )
            struct parenthesis topEle = pop(stack, &top);
            if (topEle.element == otherside(symb)){
                printf("%c%d, %d%c\n", otherside(symb), topEle.position, position, symb);
            } else {
                printf("ä½ç½®ç·¨è™Ÿ %d çš„å³æ‹¬è™Ÿ %c æ²’æœ‰å¯é…å°çš„å·¦æ‹¬è™Ÿ %c\n", position, symb, otherside(symb));
            }   
        
        }
        position++;
    }

    if (isEmpty(top)) {
        return 0;
    } else {
        while (!isEmpty(top)) {
            printf("ä½ç½®ç·¨è™Ÿ %d çš„å·¦æ‹¬è™Ÿ %c æ²’æœ‰å¯é…å°çš„å³æ‹¬è™Ÿ %c\n", stack[top--].position, stack[top].element, otherside(stack[top].element));
        }
    }

    return 0;
}
 
https://github.com/cantpr09ram/data-structure/blob/master/homework_2/part_2/main.c
GitHub
data-structure/homework_2/part_2/main.c at master Â· cantpr09ram/dat...
Contribute to cantpr09ram/data-structure development by creating an account on GitHub.
data-structure/homework_2/part_2/main.c at master Â· cantpr09ram/dat...
å“ˆå¯†è›¤ â€” æ˜¨å¤© 21:16
åœ–ç‰‡
å¥½ç¬‘å— â€” ä»Šå¤© 00:25
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#define SIZE 100

struct parenthesis {
    char element;
    int position;
};

void push(struct parenthesis stack[], int *top, int value, char element) {
    if (*top == SIZE - 1) {
        printf("Stack is full\n");
        return;
    }
    stack[++(*top)].position = value;
    stack[(*top)].element = element;
}

struct parenthesis pop(struct parenthesis stack[], int *top) {
    if (*top == -1) {
        struct parenthesis last = {
            '\0', // Change this to '\0' to represent a null character
            -1
        };
        return last; 
    }
    return stack[(*top)--];
}

struct parenthesis peek(struct parenthesis stack[], int *top) {
    if (*top == -1) {
        struct parenthesis last = {
            '\0', // Change this to '\0' to represent a null character
            -1
        };
        return last; 
    }
    return stack[(*top)];
}

bool isEmpty(int top) {
    return top == -1;
}

char otherside(char oneside){
    char otherside = '(';
    if (oneside == '}'){
        otherside = '{';
    }else if (oneside == ']'){
        otherside = '[';
    }else if(oneside == ')'){
        otherside = '(';
    }else if(oneside == '{'){
        otherside = '}';
    }else if(oneside == '['){
        otherside = ']';
    }else if(oneside == '('){
        otherside = ')';
    }
    return otherside;
}
//411440430 bo-chain
int main(int argc, char *argv[]) {

    struct parenthesis stack[SIZE] = {};
    int top = -1;
    int position = 0;

    while (1) {
        char symb = getchar();

        if (symb == '\n' || symb == EOF) {
            break;
        }
        
        if (symb == '(' || symb == '[' || symb == '{'){
            push(stack, &top, position, symb);

        } else if (symb == ')' || symb == ']' || symb == '}') {// symb = )
            struct parenthesis topEle = peek(stack, &top);
            if (topEle.element == otherside(symb)){
                printf("%c%d, %d%c\n", otherside(symb), topEle.position, position, symb);
                pop(stack, &top);
            } else {
                printf("right parenthesis %c at %d has no matching left parenthesis %c \n",symb, position, otherside(symb));
            }   
        
        }
        position++;
    }

    if (isEmpty(top)) {
        return 0;
    } else {
        while (!isEmpty(top)) {
            printf("left parenthesis %c at %d has no matching right parenthesis %c\n", stack[top--].element, stack[top].position, otherside(stack[top].element));
        }
    }

... (é‚„å‰© 6 è¡Œ)
æ”¶èµ·
main.c
3 KB
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#define SIZE 100

struct parenthesis {
å±•é–‹
main.c
3 KB
ç°¡å–®ä¾†èªªæˆ‘å€‘ä¸‹åˆçš„æ™‚å€™æ˜¯æŠŠ pop() å‡ºå»çš„æ±è¥¿åœ¨æ’¿å›ä¾† ä½†æ˜¯  pop()  å‡ºä¾†çš„å¯èƒ½æ˜¯åƒåœ¾(åœ¨å¦‚æœstackæ˜¯ç©ºçš„æƒ…æ³ä¸‹) 
è§£æ±ºçš„æ–¹æ³•ä¸€å€‹æ˜¯ç”¨ peek() ä¸€å€‹æ˜¯æ”¾æœƒå»ä¹‹å‰æª¢æŸ¥
ï»¿
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#define SIZE 100

struct parenthesis {
    char element;
    int position;
};

void push(struct parenthesis stack[], int *top, int value, char element) {
    if (*top == SIZE - 1) {
        printf("Stack is full\n");
        return;
    }
    stack[++(*top)].position = value;
    stack[(*top)].element = element;
}

struct parenthesis pop(struct parenthesis stack[], int *top) {
    if (*top == -1) {
        struct parenthesis last = {
            '\0', // Change this to '\0' to represent a null character
            -1
        };
        return last; 
    }
    return stack[(*top)--];
}

struct parenthesis peek(struct parenthesis stack[], int *top) {
    if (*top == -1) {
        struct parenthesis last = {
            '\0', // Change this to '\0' to represent a null character
            -1
        };
        return last; 
    }
    return stack[(*top)];
}

bool isEmpty(int top) {
    return top == -1;
}

char otherside(char oneside){
    char otherside = '(';
    if (oneside == '}'){
        otherside = '{';
    }else if (oneside == ']'){
        otherside = '[';
    }else if(oneside == ')'){
        otherside = '(';
    }else if(oneside == '{'){
        otherside = '}';
    }else if(oneside == '['){
        otherside = ']';
    }else if(oneside == '('){
        otherside = ')';
    }
    return otherside;
}
//411440430 bo-chain
int main(int argc, char *argv[]) {

    struct parenthesis stack[SIZE] = {};
    int top = -1;
    int position = 0;

    while (1) {
        char symb = getchar();

        if (symb == '\n' || symb == EOF) {
            break;
        }
        
        if (symb == '(' || symb == '[' || symb == '{'){
            push(stack, &top, position, symb);

        } else if (symb == ')' || symb == ']' || symb == '}') {// symb = )
            struct parenthesis topEle = peek(stack, &top);
            if (topEle.element == otherside(symb)){
                printf("%c%d, %d%c\n", otherside(symb), topEle.position, position, symb);
                pop(stack, &top);
            } else {
                printf("right parenthesis %c at %d has no matching left parenthesis %c \n",symb, position, otherside(symb));
            }   
        
        }
        position++;
    }

    if (isEmpty(top)) {
        return 0;
    } else {
        while (!isEmpty(top)) {
            printf("left parenthesis %c at %d has no matching right parenthesis %c\n", stack[top--].element, stack[top].position, otherside(stack[top].element));
        }
    }

    return 0;
}
//(((a+b)]*[[[c+d)] 
//{(a+b)*c]}}/{[d*[e+f]
//(((a+b)]*[[[c+d)]
main.c
3 KB